### 13.1 애니메이션
#### 13.1.2 Angular 애니메이션
- Angular는 CSS3를 지원하기 떄문에 에니메이션 구현이 가능하다. CSS를 이용해 애니메이션을 적용하는 것은 대체로 좋은 선택이다.
- CSS는 애니메이션의 동작을 정의할 뿐 프로그래밍 방식으로 에니메이션을 통제할 방법을 제공하지는 않는다.
- Angular의 애니메이션 시스템은 프로그래밍 방식으로 애니메이션을 통제할수 있게하며, 적은 코드로도 이러한 통제가 가능하고 사용하기 쉽다.
    - 애니메이션 사용준비  
        > app.module.ts 파일에 모듈을 추가 한다.  
        컴포넌트 장식자 내부에 animations 속성을 추가 선언한다.
### 13.2 애니메이션 기초
#### 13.2.1 트리거와 상태 정의
- 트리거는 애니메이션을 동작 시키는 방아쇠 역할을 하는 메서드이다.
- 트리거 메서드 내부에서 가장 기본이 되는 것은 상태 정의이다.
```
    animations: [trigger(
        'openClose',
        [
            state('close', style({height:'0px'})),
            state('open', style({height:'100px',paddingTop:'50px'}))
    ])]
```
#### 13.2.2 트리거 메서드와 상태 변수 간 바인딩
- 상태 메서드에서는 CSS 문법으로 스타일을 정의할 수 있다. 
- 상태 메서드를 이용하면 상태에 대한 스타일을 정의할 수 있다.
```
    <div [@트리거 이름]="상태 변수"></div>
```
#### 13.2.3 상태 전이
- 상태 전이란?
    - 상태는 아무런 움직임이 없는 정적인 스타일이다. 상태는 다른 상태로 변할 수 있다. 이를 상태 전이라고 한다. 
    - 상태 전이는 transition() 메서드의 첫 번째 매개변수를 이용해 정의 한다.

    ```
        transition('상태 A => 상태 B', animate(200))
    ```
- 단방향 상태 전이 기호
    - 단방향 상태 전이 기호는 왼쪽에서 오른쪽으로 상태가 바뀌는 것이 연상되도록 =>을 사용합니다.
- 양방향 상태 전이 기호
    - 양방향 상태 전이 기호는 close <=> open과 같이 표현한다. 
    - 이것의 의미는 close => open 또는 open => close에 대한 상태 전이를 모두 고려한다는 뜻이다
    ```
        transition('open <=> close', animate(200))
        transition('open => close','open <= close', animate(200))
    ```
- void 상태 전이 기호
    - 위의 open/close는 사용자가 정의하는 상태이다. 상태 중에는 사용자가 이름을 지정하지 않아도 이미 정해진 명시된 상태 가있다.
    - void는 아무 상태 값도 가지지 않은 상태이다. 
#### 13.2.4 애니메이션 단위
- 시간 단위
    - 애니메이션의 시간 설정을 할 때 애니메이션 지속시간에서 사용하는 시간을 설정한다.
    ```
        transition('open <=> close', animate(1000ms))
        transition('open <=> close', animate(1000))
        transition('open <=> close', animate(1s))
    ```
- 크기 단위
    - 애니메이션을 만들 때 크기를 늘리거나 크기를 줄일수 있다. 크기는 세가지 종류가 있다.
    - 10px, 10em, 10% 
    - 단위가 생략되면 기본적으로 px 단위를 적용한다.
#### 13.2.5 슬라이드 메뉴 만들기
- ex) slide-menu.component.ts
### 13.3 애니메이션 활용
#### 13.3.1 에니메이션의 타이밍 효과
- 타이밍 효과는 상태 전이 시 에니메이션의 속도와 관련된 효과이다.
- 지속, 지연, 천천히
    - 지속은 속도의 변화 없이 일정하게 진행되는 에니메이션 효과이다.
    - 지연은 속도가 0인 상태에서 잠시 대기했다가 속도가 빨라지는 에니메이션 효과이다.
    - 천천히는 천천히 속도가 올라가거나 에니메이션의 마지막 시점에 속도가 천천히 느려지는 효과이다.
- 적절한 타이밍 시간
    - 애니메이션은 적절한 타이밍 시간을 부여하는 것이 필요하다. 
    - 너무 빠르면 공격적인 느낌이 들고 에니메이션 과정도 눈으로 볼수없다.
    - 너무 느리면 UI를 보는 데 방해가 된다.
- 타이밍 예제 실습
    - ex) timing.component.ts
### 15.1 HTTP소개
#### 15.1.1 HTTP요청

restfull에는 GET,POST,PUT,PATCH,DELETE가 있음.
#### 15.1.2 프로미스 소개
프로미스는 비동기 처리를 좀더 쉽게 하기 위해 ES6에 추가된 특징.
프로미스는 입력에 대해 처리가 정상적이라면 이행됐다고 함. 이후 then()메서드를 이용해 후속처리를 진행.
프로미스 메서드

-then() 
두 함수를 매개변수로 받으며, 하나는 성공시에 호출되는 콜백 함수이며 다른 하나는 실패에 대한 콜백함수
-catch()
예외가 발생한 경우를 처리

프로미스에서 제공하는 정적 메서드
all() 입력으로 받은 모든 프로미스가 통과되면 결정(resolve)하고 그렇지 못한 경우에는 거절(reject)fmf gka.
race() 입력으로 받은 여러 프로미스 중 하나를 결정
resolve() 값을 받으면 결정
reject() 프로미스가 거절된 이유가 전달되면 프로미스 객체르 반환.

위 메서드는 자주 사용하지 않을 수 있지만 프로미스의 대표적인 메서드이므로 알아둘 필요가 있음.

#### 15.1.3 RxJS 소개
RxJS는 HTTP요청과 응답 처리과 관련해서 사용할 수 있는 반응형 프로그래밍 모델.
RxJS는 반응형 프로그래밍 방식을 사용하는 라이브러리. 반응형 프로그래밍은 이벤트에 따라 데이터를 발생시킴. 
즉, 이벤트에 따라 데이터가 흐름을 갖음.  
어떠한 상황에서 반응할지를 분류해보면 대표적으로 네가지 부류로 나눔

-부하에 반응
-사용자에 반응 
-이벤트에 반응
-실패에 반응

P.430그림 참조

합계는 국어 영어 수학점수에 영향을 받고 평균은 합계에 영향을 받음.
여기서 국어 영어 수학의 점수는 관측대상(observable)이 되고 합계는 반응형 변수 또는 관측자(observers)가 됨.
관측자는 관측대상의 상태를 구독. 이 때문에 관측자를 구독자(subscriber)라고도 함.
생각해 볼 수 있는 반응형 프로그래밍의 관점은 세 가지

- 상태관점 => 사용자 요청에 따라 일어나는 이벤트로서 이벤트의 발생시점은 사용자가 결정
- 구독자 관점 => 마우스가 이동한다면 마우스 커서의 위치가 변경된 상태를 감지해 좌표 표시를 변경할 수 있어야함.
- 데이터 흐름 => 출력이 하나로 규정되지 않고 연이은 이벤트에 따라 데이터가 발생하기 때문에 데이터의 흐름이 생김

구독과 통지
엑셀 예에서는 하나의 입력 이벤트가 드렁오면 데이터가 연달아 바뀌게 됨.
이러한 데이터의 변화를 감지하기 위해서는 데이터를 구독하는 관측자가 있어야 함.
이러한 것을 구현한것이 Observer pattern.

옵저버 패턴에서 관측 대싱안 옵저버블의 상태 변화를 관측자인 옵저버가 감시한다는 말을 다른말로 표현하면 구독한다고 말함.

#### 15.1.3 jsonp 요청을 프로미스로 처리